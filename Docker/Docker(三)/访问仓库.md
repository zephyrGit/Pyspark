# 访问仓库

- 注册
  可以在 https://hub.docker.com 免费注册一个 Docker 账号。
- 登录
  可以通过执行 docker login 命令交互式的输入用户名及密码来完成在命令行界
  面登录 Docker Hub。
- 可以通过 docker logout 退出登录

- 拉取镜像
  你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker
  pull 命令来将它下载到本地。

~~~shell
$ sudo docker search centos
NAME DESCRIPTION STARS OFFICIAL AUTOMATED
centos The official build of CentOS. 465 [OK] tianon/centos CentOS 5 and 6,created using rinse instea... 28 blalor/centos Bare-bones base
CentOS 6.5 image 6 [OK]
saltstack/centos-6-minimal6 [OK] tutum/centos-6.4 DEPRECATED. Use tutum/centos:6.4 instead. ... 5 [OK]
~~~

在查找的时候通过 --filter=stars=N 参数可以指定仅显示收藏数量为 N 以上的镜像。

- 推送镜像
  用户也可以在登录后通过 docker push 命令来将自己的镜像推送到 Docker
  Hub。
  以下命令中的 username 请替换为你的 Docker 账号用户名。

~~~shell
$ docker tag ubuntu:18.04 username/ubuntu:18.04
$ docker image ls
REPOSITORY TAG     IMAGE   ID    CREATED 		SIZE
ubuntu 18.04  275d79972a86 		6 days ago      94.6MB
username/ubuntu 18.04  275d79972a86 6 days ago  94.6MB
$ docker push username/ubuntu:18.04
$ docker search username
~~~

- 私有仓库
  有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。

docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 docker-registry v2.x 版本。

## 安装运行 docker-registry
容器运行

可以通过获取官方 registry 镜像来运行。

~~~shell
$ docker run -d -p 5000:5000 --restart=always --name registry re
gistry
~~~

这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的/opt/data/registry 目录。

~~~shell
$ docker run -d \
    -p 5000:5000 \
    -v /opt/data/registry:/var/lib/registry \
	registry
~~~

### 在私有仓库上传、搜索、下载镜像

创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 127.0.0.1:5000 。使用 docker tag 将 ubuntu:latest 这个镜像标记为127.0.0.1:5000/ubuntu:latest 

格式为 docker tag IMAGE[:TAG]
[REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG] 

~~~shell
$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest
$ docker image ls
REPOSITORY TAG IMAGE ID   CREATED VIRTUAL SIZE
ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB
127.0.0.1:5000/ubuntu:latest latest ba5877dc9bec 6 weeks ago 192.7 MB
~~~

使用 docker push 上传标记的镜像。

~~~shell
master@ML:~$ sudo docker push 127.0.0.1:5000/ubuntu:lastest
The push refers to repository [127.0.0.1:5000/ubuntu]
b57c79f4a9f3: Pushed 
d60e01b37e74: Pushed 
e45cfbc98a50: Pushed 
762d8e1a6054: Pushed 
lastest: digest: sha256:f2557f94cac1cc4509d0483cb6e302da841ecd6f82eb2e91dc7ba6cfd0c580ab size: 1150
~~~

用 curl 查看仓库中的镜像

~~~shell
master@ML:~$ curl 127.0.0.1:5000/v2/_catalog
{"repositories":["ubuntu"]}
~~~

### Nexus3.x 的私有仓库

使用 Docker 官方的 Registry 创建的仓库面临一些维护问题。比如某些镜像删除以
后空间默认是不会回收的，需要一些命令去回收空间然后重启 Registry 程序。在企
业中把内部的一些工具包放入 Nexus 中是比较常见的做法，最新版本 Nexus3.x全面支持 Docker 的私有镜像。所以使用 Nexus3.x 一个软件来管理 Docker ,Maven , Yum , PyPI 等是一个明智的选择。

#### 启动 Nexus 容器

~~~shell
$ docker run -d --name nexus3 --restart=always \
    -p 8081:8081 \
    --mount src=nexus-data,target=/nexus-data \
    sonatype/nexus3
~~~

#### Docker 数据管理

容器中数据主要有两种方式：

- 数据卷
- 挂载主机目录

##### 数据卷

数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS ，可以提供很多有用的特性

- 数据卷 可以再容器之间共享和重用
- 对 数据卷 的修改会立马生效
- 对 数据卷 的更新，不会影响镜像
- 数据卷 默认会一直存在，即使容器被删除

**注意： 数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷 。**

##### 创建一个数据卷

~~~shell
master@ML:/usr/local/d$ sudo docker volume create my_vol
[sudo] password for master:         
my_vol
master@ML:/usr/local/d$ sudo docker volume ls
DRIVER              VOLUME NAME
local               5146194b4e56c11351bf62aaddcedcee6024b44c133028148b9b3b4f6fe3e572
local               my_vol
local               nexus-data
master@ML:/usr/local/d$ 
~~~

使用以下命令查看 数据卷 的信息

~~~shell
master@ML:/usr/local/d$ sudo docker volume inspect my_vol
[
    {
        "CreatedAt": "2019-03-28T14:01:51+08:00",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/my_vol/_data",
        "Name": "my_vol",
        "Options": {},
        "Scope": "local"
    }
]
~~~

##### 启动一个挂载数据卷的容器

使用 docker run 命令的时候，使用 --mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷

创建一个名为 web 的容器，加载 数据卷到容器的 /webapp 目录

~~~shell
master@ML:/usr/local/d$ sudo docker run -d -P --name web --mount source=my_vol,target=/webapp\
> training/webapp \
> python app.py
Unable to find image 'python:latest' locally
latest: Pulling from library/python

~~~

##### 查看数据卷的具体信息

在主机里使用以下命令 查看 web 容器的信息

~~~shell
$ sudo docker inspect web
~~~

清理无主数据卷 命令

~~~shell
$ sudo docker volume prune
~~~

##### 挂载一个本地主机文件作为数据卷

~~~shell
master@ML:/$ sudo docker run --rm -it --mount type=bind,source=$HOME/.bash_history,target=/root/.
bash_history ubuntu:18.04 bashUnable to find image 'ubuntu:18.04' locally
18.04: Pulling from library/ubuntu
Digest: sha256:017eef0b616011647b269b5c65826e2e2ebddbe5d1f8c1e56b3599fb14fabec8
Status: Downloaded newer image for ubuntu:18.04
root@25c0f3d33526:/# history
    1  sudo passwd root
    2  ip addr
    3  sudo apt-get install vim
    4  ls
    5  ip addr
~~~

可以查看在容器中输入过的命令

# Docker 中网络功能

### 外部访问容器

- 容器中可以运行一些网络应用，可以通过 -P 或 -p 参数来指定端口映射

当使用 -P 标记时，Docker 会随机映射一个 49000~49900 端口到内部容器开放的网络端口

~~~shell
master@ML:/$ sudo docker run -d -P training/webapp python app.py
ec6843e527d3af54b1128f59edb1341272cd13ead57eff26f6109a14d7067bc1
master@ML:/$ sudo docker container ls -l
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS           
   PORTS                     NAMESec6843e527d3        training/webapp     "python app.py"     23 seconds ago      Up 21 seconds    
   0.0.0.0:32768->5000/tcp   silly_lehmann
~~~

- 映射所有接口地址

~~~shell
master@ML:/$ sudo docker run -d -p 5000:5000 training/webapp python app.py
d1698b26567a77ef29803897a1e4013f08a716bed8071fbb4f29817b259de7b1
~~~

- 映射到指定地址的指定端口

~~~shell
$ sudo docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py
~~~

- 映射到指定地址的任意端口

~~~shell
$ sudo docker run -d -p 127.0.0.1::5000 training/webapp python app.py
~~~

- 使用 udp 标记来指定 udp 端口

~~~shell
$ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
~~~

- 查看映射端口配置

使用  docker port 来查看当前映射的端口配置

~~~shell
$ docker port nostalgic_morse 5000
127.0.0.1：49155.
~~~

注：

- 容器有自己的内部网络和ip地址
- -p 标记可以多次使用来绑定多个端口

~~~shell
master@ML:/$ sudo docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py
cb39e6e55f0b292503b1eeb68232d9ac6cb1491573a4d96af7946b13358a3e21
~~~

### 容器互联

- 新建网络

~~~shell
$ sudo docker network create -d bridge my_net
# -d 参数指定 Docker 网络类型，有bridge overlay 。
~~~

-  连接容器

~~~shell
# 运行一个容器并连接到新建的 my-net 网络
master@ML:/$ sudo docker run -it --rm --name busybox1 --network my_net busybox sh
Unable to find image 'busybox:latest' locally
latest: Pulling from library/busybox
697743189b6d: Pull complete 
Digest: sha256:061ca9704a714ee3e8b80523ec720c64f6209ad3f97c0ff7cb9ec7d19f15149f
Status: Downloaded newer image for busybox:latest
~~~

打开新的终端，再运行一个容器并加入到 my-net 网络

~~~shell
master@ML:~$ sudo docker run -it --rm --name busybox2 --network my_net busybox sh
/ # 
~~~

再打开一个新的终端查看容器信息

~~~shell
master@ML:~$ sudo docker container ls
[sudo] password for master:         
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS           
   PORTS                                          NAMES119753e58c8c        busybox             "sh"                26 seconds ago      Up 24 seconds    
                                                  busybox20d33292dc685        busybox             "sh"                2 minutes ago       Up 2 minutes     
                                                  busybox1cb39e6e55f0b        training/webapp     "python app.py"     13 minutes ago      Up 13 minutes    
   0.0.0.0:5000->5000/tcp, 0.0.0.0:3000->80/tcp   friendly_tumaster@ML:~$ 
~~~

通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系

~~~shell
# 在 busybox1 容器输入命令
/ # ping busybox2
PING busybox2 (172.18.0.3): 56 data bytes
64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.238 ms
64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.298 ms
~~~

同理在 busybox2 执行 ping

~~~shell
/ # ping busybox1
PING busybox1 (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.266 ms
64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.120 ms
~~~

### 配置 DNS

 Docker 容器的 DNS 配置通过 /etc/resolv.conf 文件立刻得到更新。

配置全部容器的 DNS ，也可以在 /etc/docker/daemon.json 文件中增加以下
内容来设置。

~~~bash
{
    "dns" : [
    "114.114.114.114",
    "8.8.8.8"
   ]
}
~~~

每次启动容器 DNS 自动配置为 “114.114.114.114、 8.8.8.8” 。查看

~~~shell
master@ML:/$ sudo docker run -it --rm ubuntu cat etc/resolv.conf
# This file is managed by man:systemd-resolved(8). Do not edit.
#
# This is a dynamic resolv.conf file for connecting local clients directly to
# all known uplink DNS servers. This file lists all configured search domains.
#
# Third party programs must not access this file directly, but only through the
# symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a different way,
# replace this symlink by a static file or a different symlink.
#
# See man:systemd-resolved.service(8) for details about the supported modes of
# operation for /etc/resolv.conf.

nameserver 114.114.114.114
nameserver 8.8.8.8
~~~

手动指定容器的配置，可以在使用 docker run 命令启动容器时加入如下参数：

-h HOSTNAME 或 --hostname=HOSTNAME 设定容器的主机名，会被写到容器内的 /ect/hostname 和 /etc/hosts 。不会被 docker container ls 显示，也不会被 /etc/hosts 显示

--dns=IP_ADDRESS 添加 DNS 服务器到容器的 /etc/resolv.conf 中让容器用这个 服务器来解析所有不在 /etc/hosts 中的主机名

--dns-search=DOMAIN 设定容器的搜索域， 当设定搜索域为 .example.com 时，在搜索给名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com

**注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的
/etc/resolv.conf 来配置容器**

### 高级网络配置

当 Docker 启动时会自动在主机上创建应给docker0 虚拟网桥，实际上时Linux的brdge，可以理解为一个软件交换机。

当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0 ；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT ）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。

![1553764723810](C:\Users\sky\AppData\Roaming\Typora\typora-user-images\1553764723810.png)

#### 快速配置

Docker 网络相关的命令列表

有些命令只有在 Docker 服务启动的时候才能配置，而且不能马上生效

- b -BRIDGE 或 --brige=BRIDGE 指定容器挂载的网桥
- --bip=CIDR 定制 docker0 的掩码
- -H SOCKERT .. 或 --host=SOCKET ... Docker 服务端接收命令的通道
- --icc=true|false 是否支持容器之间进行通信
- --ip-forward=true|false 容器之间的通信
- --iptables=true|false 是否允许Docker添加 iptables 规则
- --mtu=BYTES 容器网络中的 MTU

下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker
服务启动的时候指定则会成为默认值，后面执行 docker run 时可以覆盖设置的默认值。

- --dns=IP_ADDRESS... 使用指定的DNS服务器
- --dns-search=DOMAIN... 指定DNS搜索域

最后这些选项只有在 docker run 执行时使用，因为它是针对容器的特性内容。

- -h HOSTNAME 或 --hostname=HOSTNAME 配置容器主机名
- --link=CONTAINER_NAME:ALIAS 添加到另一个容器的连接
- --net=bridge|none|container:NAME_or_ID|host 配置容器的桥接模式
- -p SPEC 或 --publish=SPEC 映射容器端口到宿主主机
- -P or --publish-all=true|false 映射容器所有端口到宿主主机

#### 容器访问控制

容器访问控制，通过 Linux 上的 iptables 防火墙来进行管理和实现。

#### 容器访问外部网络

容器要访问外部网络，需要本地系统的转发支持。

~~~shell
# 检查转发状态
master@ML:~$ sudo sysctl net.ipv4.ip_forward
[sudo] password for master:         
net.ipv4.ip_forward = 1
~~~

如果为 0 ，说明 没有开启转发，则要手动打开

~~~shell
master@ML:~$ sudo sysctl -w net.ipv4.ip_forward=1
~~~

如果启动 Docker 服务的时候设定 --ip-forward=true，Docker 会自动设定系统的 ip_forward 参数为1

#### 容器之间访问

容器之间相互访问

- 容器的网络拓扑是否已经互联。默认所有容器会被连接到 docker0 网桥上
- 本地系统的防火墙软件 --IP tables 是否允许通过

访问所有端口

启动 Docker 服务的时候，默认会添加一调转发策略到本地主机 iptables 的 FORWARD链上，策略为通过还是禁止取决于配置 --icc=true 还是 --icc=false。如果手动指定 --iptables=false 则不会添加 iptables 规则

默认情况下，不同容器之间是允许网络互通的。 可以在 /etc/docekr/daemon.json 文件中配置 {"icc":"false"}来禁止它。ubuntu：14.04等使用 upstart的系统在 文件/etc/default/docker 中配置 （DOCKER_OPTS=--icc=false）

#### 访问指定端口

在通过 -icc=false 关闭网络访问后，还可以通过 --link=CONTAINER_NAME:ALIAS 选项来访问容器的开放端口

~~~shell
$ sudo iptables -nL
...
Chain FORWARD (policy ACCEPT)
target prot opt source destination
DROP all -- 0.0.0.0/0 0.0.0.0/0
...
~~~

启动容器（ docker run ）时使用 --link=CONTAINER_NAME:ALIAS 选项。Docker 会在 iptable 中为 两个容器分别添加一条 ACCEPT 规则，允许相互访问开放的端口（取决于 Dockerfile 中的 EXPOSE 指令）

**注意： --link=CONTAINER_NAME:ALIAS 中的 CONTAINER_NAME 目前必须是Docker 分配的名字，或使用 --name 参数指定的名字。主机名则不会被识别。**

