# 访问容器（三）

### 高级网络配置

当 Docker 启动时，会自动在主机创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会挂载到它的网口之间进行转发

同时， Docker 随机分配一个本地未占用的私有网段（在 RFC1918中定义）中的一个地址给 docker0 接口。比如典型的 172.17.42.1， 掩码为255.255.0.0.此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址

当创建一个 Docker 容器的时候，同时会创建一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容
器内，即 eth0 ；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开
头（例如 vethAQI2QT ）。通过这种方式，主机可以跟容器通信，容器之间也可
以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。

![1553220000457](C:\Users\sky\AppData\Roaming\Typora\typora-user-images\1553220000457.png)

Docker所有的网络定制配置。以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认网络配置

#### 快速配置指南

与 Docker 网络相关的命令列表

其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效

- -b BRIDGE or --bridge=BRIDGE --指定容器挂载的网桥
- --bip=CIDR --定制 docker0 的掩码
- -H  SOCKET ... or --host=SOCKET... --Docker 服务端接收命令的通道
- --icc=true|false --是否支持容器之间进行通信
- --ip-forward=true|false --请看下文容器之间的通信
- --iptables=true|false --是否允许 Docker 添加 iptables 规则
- --mtu=BYTES --容器网络中的 MTU

下面2个命令选项既可以在启动服务时指定，也可以 Docker 容器启动( docker run) 时候指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 docker run 时可以覆盖设置的默认值

- --dns=IP_ADDRESS... --使用指定的DNS服务器
- --dns-search=DOMAIN... --指定DNS搜索域

最后这些选项只有在 docker run 执行时使用，因为它时针对容器的特性内容

- -h HOSTNAME or --hostname=HOSTNAME --配置容器主机名
- --link=CONTAINER_NAME:ALIAS --添加到另一个容器的连接
- --net=bridge|none|container：NAME_or_ID|host --配置容器的桥接模式
- -p SPEC or --publish=SPEC --映射容器端口到宿主主机
- -P or --publish-all=true|false --映射容器所有端口到宿主主机

#### 配置DNS

Docker 没有为每个容器专门定制镜像，利用虚拟文件来挂载到容器的3个相关配置文件，配置容器的主机名和DNS

在容器中使用mount命令可以看到挂载信息

~~~~shell
[root@localhost ~]# mount
...
/dev/sda1 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,seclabel,size=186324k,mode=700)
~~~~

这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 dns 配置通过 /etc/resolv.conf 文件立刻得到更新

若要手动指定容器的配置，可以利用下面选项

-h HOSTNAME or --hostname=HOSTNAME 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。但它在容器外部看不到，既不会在 docker ps 中显示，也不会在其它容器的 /etc/hosts 看到

--link=CONTAINER_NAME:ALIAS 选项会在创建容器的时候，添加一个其他容器
的主机名到 /etc/hosts 文件中，让新容器的进程可以使用主机名 ALIAS 就可以
连接它。
--dns=IP_ADDRESS 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容
器用这个服务器来解析所有不在 /etc/hosts 中的主机名。
--dns-search=DOMAIN 设定容器的搜索域，当设定搜索域为 .example.com
时，在搜索一个名为 host 的主机时，DNS 不仅搜索host，还会搜索
host.example.com 。 注意：如果没有上述最后 2 个选项，Docker 会默认用主
机上的 /etc/resolv.conf 来配置容器。

#### 容器访问控制

容器的访问，主要通过 Linux 上的 iptables 防火墙来进行管理和实现。iptables 是 Linux上默认的防火墙软件

#### 容器访问外部网络

容器想要访问外部网络，需要本地系统的转发支持。在 Linux 系统中，检查转发是否打开

~~~shell
[root@localhost ~]# sysctl net.ipv4.ip_forward
net.ipv4.ip_forward = 1
~~~

如果为 0 ，说明没有开启转发，则需要手动打开

~~~shell
[root@localhost ~]# sysctl -w net.ipv4.ip_forward=1
net.ipv4.ip_forward = 1
~~~

**容器之间访问**

容器之间相互访问，需要两方面的支持

- 容器的网络拓扑是否已经互联。默认情况下，所有容器会被连接到 docker0 网桥上
- 本地系统的防火墙软件 --iptables 是否允许通过

**访问所有端口**

当启动 Docker 服务时候，默认会添加一条抓发策略到 iptables 的 FORWARD链上。策略为通过（ACCEPT）还是禁止（DROP）取决于配置 --icc=true（缺省值）还是 --icc=false。当然，如果手动指定 --iptables=false 则不会添加 iptables 规则

可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 /etc/default/docekr 文件中配置 DOCKER_OPTS=--icc=false来禁止它

**访问指定端口**

在通过 -icc=false 关闭网络访问后，还可以通过 --link=CONTAINER_NAME:ALIAS 选项来访问容器的开放端口。

例如，在启动 Docker 服务时，可以同时使用 icc=false --iptables=true 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 iptables 规则

此时，系统中的 iptables 规则可能类似

~~~shell
[root@localhost ~]# iptables -nL
...
Chain FORWARD (policy ACCEPT)
target prot opt source destination
DROP all -- 0.0.0.0/0 0.0.0.0/0
...
~~~

之后，启动容器（ docker run ）时使用 --link=CONTAINER_NAME:ALIAS 选
项。Docker 会在 iptable 中为 两个容器分别添加一条 ACCEPT 规则，允许相互访问开放的端口（取决于 Dockerfile 中的 EXPOSE 行）。当添加了 --link=CONTAINER_NAME:ALIAS 选项后，添加了 iptables 规则。

~~~shell
[root@localhost ~]# iptables -nL
...
Chain FORWARD (policy ACCEPT)
target prot opt source destination
ACCEPT tcp -- 172.17.0.2 172.17.0.3 tc
p spt:80
ACCEPT tcp -- 172.17.0.3 172.17.0.2 tc
p dpt:80
DROP all -- 0.0.0.0/0 0.0.0.0/0
~~~

注意： --link=CONTAINER_NAME:ALIAS 中的 CONTAINER_NAME 目前必须是 Docker 分配的名字，或使用 --name 参数指定的名字。主机名则不会被识别。

**映射容器端口到宿主主机的实现**

默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。

**容器访问外部实现**
容器所有到外部网络的连接，源地址都会被NAT成本地系统的IP地址。这是使用 iptables 的源地址伪装操作实现的。
查看主机的 NAT 规则。

~~~shell
[root@localhost ~]# sudo iptables -t nat -nL
...
Chain POSTROUTING (policy ACCEPT)
target prot opt source destination
MASQUERADE all -- 172.17.0.0/16 !172.17.0.0/16
...
~~~

其中，上述规则将所有源地址在 172.17.0.0/16 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。

**外部访问容器实现**

容器允许外部访问，可以在 docker run 时候通过 -p 或 -P 参数来启用。
不管用那种办法，其实也是在本地的 iptable 的 nat 表中添加相应的规则。使用 -P 时：

~~~shell
[root@localhost ~]# iptables -t nat -nL
...
Chain DOCKER (2 references)
target prot opt source destination
DNAT tcp -- 0.0.0.0/0 0.0.0.0/0 tc
p dpt:49153 to:172.17.0.2:80
~~~

使用 -p 80:80 时：

~~~shell
[root@localhost ~]# iptables -t nat -nL
Chain DOCKER (2 references)
target prot opt source destination
DNAT tcp -- 0.0.0.0/0 0.0.0.0/0 tc
p dpt:80 to:172.17.0.2:80
~~~

注意：

- 这里的规则映射了 0.0.0.0，意味着将接受主机来自所有接口的流量。用户可以通过 -p IP:host_port:container_port 或 -p IP::port 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。
- 如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件
  /etc/default/docker 中指定 DOCKER_OPTS="--ip=IP_ADDRESS" ，之后重启 Docker 服务即可生效。

#### 配置 docker0 网桥

Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接
口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。

Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。

- --bip=CIDR --IP 地址加掩码格式，如192.168.1.5/24
- --mtu=BYTES --覆盖默认的 Docker mtu 配置

也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。由于目前Docker 网桥是 Linux 网桥，用户也可使用 brctl show 来查看网桥和端口连接信息

~~~shell
# 使用 brctl show
[root@localhost ~]# brctl show
bridge name	bridge id		STP enabled	interfaces
docker0		8000.0242757d9721	no		
~~~

**注：brctl 命令在 Debian、Ubuntu中可以使用 sudo apt-get install  bridge-utils 来安装；CentOS 使用 sudo yum install bridge-utils 安装**

每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 docker0 接口的 IP 作为所有容器的默认网关

~~~shell
$ sudo docker run -i -t --rm base /bin/bash
$ ip addr show eth0
24: eth0: <BROADCAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast stat
e UP group default qlen 1000
link/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff
inet 172.17.0.3/16 scope global eth0
valid_lft forever preferred_lft forever
inet6 fe80::306f:e0ff:fe35:5791/64 scope link
valid_lft forever preferred_lft forever
$ ip route
default via 172.17.42.1 dev eth0
172.17.0.0/16 dev eth0 proto kernel scope link src 172.17.0.3
$ exit
~~~

**自定义网桥**

除了默认的 docker0 网桥，用户也可以指定网桥来连接各个容器。在启动 Docker 服务的时候，使用 -b BRIDGE 或 --bridge=BRIDGE 来指定使用的网桥。
如果服务已经运行，那需要先停止服务，并删除旧的网桥。

~~~shell
# 停止服务
[root@localhost ~]# sudo service docker stop
Redirecting to /bin/systemctl stop docker.service
# 删除网桥
[root@localhost ~]# sudo ip link set dev docker0 down
[root@localhost ~]# sudo brctl delbr docker0
#创建新网桥
[root@localhost ~]# sudo brctl addbr bridge0
[root@localhost ~]# sudo ip addr add 192.168.5.1/24 dev bridge0
[root@localhost ~]# ip link set dev bridge0 up
# 查看确认网桥创建并启动
[root@localhost ~]# ip addr show bridge0
4: bridge0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UNKNOWN group defaul
t qlen 1000    link/ether fe:75:ca:22:3a:6f brd ff:ff:ff:ff:ff:ff
    inet 192.168.5.1/24 scope global bridge0
       valid_lft forever preferred_lft forever
    inet6 fe80::fc75:caff:fe22:3a6f/64 scope link 
       valid_lft forever preferred_lft forever
 
# 配置 Docker服务，默认桥接到创建的网桥上
[root@localhost ~]# echo 'DOCKER_OPTS="-b=bridge0"' >> /etc/default/docker
[root@localhost ~]# service docker start
Redirecting to /bin/systemctl start docker.service
~~~

启动 Docker 服务。 新建一个容器，可以看到它已经桥接到了 bridge0 上。自定义网桥可以继续用 brctl show 命令查看桥接的信息。另外，在容器中可以使用 ip addr 和 ip route 命令来查看 IP 地址配置和路由信息。

~~~shell
[root@localhost ~]# ip route
default via 192.168.202.2 dev ens33 proto static metric 100 
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 
192.168.5.0/24 dev bridge0 proto kernel scope link src 192.168.5.1 
192.168.202.0/24 dev ens33 proto kernel scope link src 192.168.202.131 metric 100 
~~~