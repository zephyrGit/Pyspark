# 访问仓库（四）

### 工具和示例

#### pipework

Jérôme Petazzoni编写了一个叫 [pipework](https://github.com/jpetazzo/pipework)的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。

#### playground

Brandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 [Python库](https://github.com/brandon-rhodes/fopnp/tree/m/playground)，
包括路由、NAT 防火墙；以及一些提供 HTTP, SMTP, POP, IMAP, Telnet, SSH,
FTP 的服务器。

#### 编辑网络配置文件

Docker 1.2.0 开始支持在运行中的容器里编辑 /etc/hosts， /etc/hostname 和 /ect/resolve.conf 文件

但是这些修改时临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来。也不会被 docker commit 提交

#### 示例：创建一个点到点连接

默认情况下，Docker 会将所有容器连接到由 docker0 提供的虚拟子网中。
用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。
解决办法很简单：创建一对 peer 接口，分别放到两个容器中，配置成点到点链
路类型即可。
首先启动 2 个容器：

~~~shell
[root@localhost ~]# docker run -i -t --rm --net=none centos /bin/bash
[root@c4a0c7a86d46 /]#
[root@localhost ~]# sudo docker run -i -t --rm --net=none ubuntu:16.04 /bin/bash
root@6fae7527e9d3:/#
# 找到进程号
[root@localhost ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS    PORTS               NAMES6fae7527e9d3        ubuntu:16.04        "/bin/bash"              2 minutes ago       Up 2 minutes                              modest_sutherland
c4a0c7a86d46 			 centos              "/bin/bash"              4 minutes ago       Up 4 minutes
# 然后创建网络命名空间的跟踪文件
[root@localhost ~]# docker inspect -f '{{.State.Pid}}' c4a0c7a86d46 
18036
[root@localhost ~]# docker inspect -f '{{.State.Pid}}' 6fae7527e9d3
18191
[root@localhost ~]# mkdir -p /var/run/netns
[root@localhost ~]# ln -s /proc/18036/ns/net /var/run/netns/18036
[root@localhost ~]# ln -s /proc/18191/ns/net /var/run/netns/18191
~~~

创建一对 peer 接口，然后配置路由

~~~shell
# 创建 A 接口
[root@localhost ~]# ip link add A type veth peer name B
[root@localhost ~]# ip link set A netns 18036
[root@localhost ~]# ip netns exec 18036 ip addr add 10.1.1.1/32 dev A
[root@localhost ~]# ip netns exec 18036 ip link set A up
[root@localhost ~]# ip netns exec 18036 ip route add 10.1.1.1/32 dev A

# 创建B接口
[root@localhost ~]# ip link set B netns 18191
[root@localhost ~]# ip netns exec 18191 ip addr add 10.1.1.1/32 dev B
[root@localhost ~]# ip netns exec 18191 ip link set B up
[root@localhost ~]# ip netns exec 18191 ip route add 10.1.1.1/32 dev B
~~~

现在这连个容器就可以相互ping通，并成功建立连接。点到点链路不需要子网和子网掩码

此外也可以不指定 --net=none 来创建点到点的链路。这样可以通过原网络来同信

利用类似的方法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 --icc=false 来关闭容器之间的通信

## 实战

场景 - 案例

### 使用 Supervisor 来管理进程

Docker 容器在启动的时候开启单个进程，比如，一个 ssh 或者 apache 的 daemon
服务。但我们经常需要在一个机器上开启多个服务，这可以有很多方法，最简单的
就是把多个启动命令放到一个启动脚本里面，启动的时候直接启动这个脚本，另外
就是安装进程管理工具

进程管理工具 supervisor 来管理容器中的多个进程。使用 Supervisor可以更好的控制、管理、重启我们希望运行的进程。

#### 配置

创建一个 Docker file，内容和部分解释

首先创一个文件夹叫做`supervisor`,目录结构为

```bash
~/Docker tree supervisor
supervisor
├── Dockerfile
└── supervisord
```

其中文件Dockerfile文件内容为：

~~~shell
#使用时哪个镜像
FROM ubuntu:14.04
MAINTAINER examples@docker.com
RUN echo "deb http://archive.ubuntu.com/ubuntu precise main universe" > /etc/apt/sources.list
RUN apt-get update
RUN apt-get upgrade -y

#这里安装 3 个软件，还创建了 2 个 ssh 和 supervisor 服务正常运行所需要的目录。
RUN apt-get install -y --force-yes perl-base=5.14.2-6ubuntu2
RUN apt-get install -y apache2.2-common
RUN apt-get install -y openssh-server apache2 supervisor
RUN mkdir -p /var/run/sshd
RUN mkdir -p /var/log/supervisor

#添加 supervisord 的配置文件，并复制配置文件到对应目录下面。
COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf

#映射了 22 和 80 端口，使用 supervisord 的可执行路径启动服务
EXPOSE 22 80
CMD ["/usr/bin/supervisord"]
~~~

**supervisor配置文件内容**

~~~shell
#supervsord 配置软件本身，使用 nodaemon 参数来运行
[supervisord]
nodaemon=true

#配置两个服务
[program:sshd]
command=/usr/sbin/sshd -D
[program:apache2]
command=/bin/bash -c "source /etc/apache2/envvars && exec /usr/sbin/apache2 -DFOREGROUND"
~~~



**使用方法**

~~~shell
# 创建镜像
$ sudo docker build -t test/supervisord .
~~~

启动 supervisor 容器

~~~shell
Sending build context to Docker daemon 3.584 kB
Step 1 : FROM ubuntu:13.04
---> a58cd502f927
Step 2 : MAINTAINER examples@docker.com
---> Using cache
---> 15f104cdeb77
Step 3 : RUN echo "deb http://archive.ubuntu.com/ubuntu precise main universe" > /etc/apt/sources.list
---> Using cache
---> c6bb44d794ea
Step 4 : RUN apt-get update
---> Using cache
---> adcd83eecb0d
Step 5 : RUN apt-get upgrade -y
---> Using cache
---> 89e045811261
Step 6 : RUN apt-get install -y --force-yes perl-base=5.14.2-6ubuntu2
---> Using cache
---> bcdc472cc73a
Step 7 : RUN apt-get install -y apache2.2-common
---> Using cache
---> d8991f8aa3c6
Step 8 : RUN apt-get install -y openssh-server apache2 supervisor
---> Using cache
---> a713034800d6
Step 9 : RUN mkdir -p /var/run/sshd
---> Using cache
---> 3138e3644958
Step 10 : RUN mkdir -p /var/log/supervisor
---> Using cache
---> 958c08978b0c
Step 11 : COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf
---> 8e9a0c97a133
Removing intermediate container d95b58057f73
Step 12 : EXPOSE 22 80
---> Running in 9cabb0865159
---> b4aa8b82cd57
Removing intermediate container 9cabb0865159
Step 13 : CMD /usr/bin/supervisord
---> Running in 237f71166211
---> 569f95736129
Removing intermediate container 237f71166211
Successfully built 569f95736129
~~~

