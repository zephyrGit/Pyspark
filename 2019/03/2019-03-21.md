# 访问仓库

仓库(Repository)是集中存放镜像的地方

## Docker Hub

Docker 官方维护的一个公共仓库Docker Hub

### 登录

可以通过 docker login 命令来输入用户名 、密码和邮箱来完成注册和登录，注册成功后，本地用户目录的.dockercfg 中保存用户的认证信息

### 基本操作

可以通过 docker search 命令来查找仓库中的镜像，并利用Docker pull 命令来下载到本地

~~~shell
[root@localhost docker]# docker search python
NAME                                   DESCRIPTION                             
        STARS               OFFICIAL            AUTOMATEDpython                                 Python is an interpreted, interactive, o
bjec…   3978                [OK]                django                                 Django is a free web application framewo
rk, …   800                 [OK]                pypy                                   PyPy is a fast, compliant alternative im
plem…   172                 [OK]                kaggle/python                          Docker image for Python scripts run on K
aggle   110                                     [OK]frolvlad/alpine-python3                The smallest Docker image with Python 3.
5 (~…   96                                      [OK]azuresdk/azure-cli-python              For official Azure CLI 2.0 builds, see h
ttps…   37                                      [OK]centos/python-35-centos7               Platform for building and running Python
 3.5…   33  
 ...
~~~

其中包括镜像名字，描述，星标，是否官方创建，是否自动创建等

另外可以在查找的时候通过 -s N参数来指定仅显示评价为N星以上的镜像

~~~shell
[root@localhost docker]# docker pull mysql
Using default tag: latest
latest: Pulling from library/mysql
f7e2b70d04ae: Downloading   15.9MB/22.5MB
df7f6307ff0a: Download complete 
e29ed02b1013: Download complete 
9cb929db392c: Download complete 
42cc77b24286: Download complete 
a6d57750cc73: Downloading  9.219MB/12.11MB
79510826e343: Download complete 
0bff56f688ad: Download complete 
b7900ad0eff9: Waiting 
9ffa71cbd4ba: Waiting 
3d744b02cc8e: Waiting 
75b0db54e16c: Waiting 
~~~

可以通过 docker push 命令来将镜像推送到Docker Hub

### 自动创建

自动创建，对于需要经常升级镜像内程序非常方便

自动创建，允许用户通过一个指定跟踪系统（目前支持GitHub和bitBucket）上的项目，一旦项目发生新的提交，则自动进行执行创建

配置自动创建步骤

- 创建并登录Docker Hub，以及目标网站
- 在目标网站中链接账号到Docker Hub
- 在Docker Hub中配置一个自动创建
- 选取一个目标网站中的项目（需要Dockerfile）和分支
- 指定Dockerfile的位置，并提交创建

之后可以在Docker Hub的自动创建页面跟踪每次创建的状态

### 私有仓库

docker-registry是官方提供的工具，可以用户构建私有的镜像仓库

#### 安装运行 docker-registry

- 容器运行

在安装Docker后，可以通过获取官方registry镜像来运行

~~~shell
[root@localhost docker]# docker run -d -p 5000:5000 registry
~~~



这将使用官方的registry镜像来启动本地的私有仓库。可以通过指定参数来配置私有仓库的位置，例如配置镜像存储到Amazon S3服务

~~~shell
[root@localhost docker]# docker run \
> -e SETTINGS_FLAVOR=s3 \
> -e AWS_BUCKET=acme-docker \
> -e STORAGE_PATH=/registry \
> -e AWS_KEY=AKIAHSHB43HS3J92MXZ \
> -e AWS_SECRET=xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T \
> -e SEARCH_BACKEND=sqlalchemy \
> -p 5000:5000 \
> registry
~~~

此外，还可以指定本地路径（如/home/usr/registry-conf）下的配置文件

~~~shell
docker run -d -p 5000:5000 -v /home/user/registry-conf:/r
egistry-conf -e DOCKER_REGISTRY_CONFIG=/registry-conf/config.yml
registry
~~~

默认情况下，仓库会被创建在容器的/tmp/registry下，可以通过 -v 参数来将镜像文件存储在本地的指定路径，

~~~shell
$ sudo docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/reg
istry registry
~~~

### 本地安装

对于 Ubuntu 或 CentOS等发行版，可以直接通过源安装

- Ubuntu

~~~shell
sudo apt-get install -y build-essential python-dev libeven
t-dev python-pip liblzma-dev
$ sudo pip install docker-registry
~~~

- CentOS

~~~shell
 [root@localhost ~]# yum install -y python-devel libevent-devel python-pip gcc x
z-devel

[root@localhost ~]# sudo python-pip install docker-registry
~~~

也可以从 docker-registry 项目下载源码进行安装

~~~shell
$ sudo apt-get install build-essential python-dev libevent-dev p
ython-pip libssl-dev liblzma-dev libffi-dev
$ git clone https://github.com/docker/docker-registry.git
$ cd docker-registry
$ sudo python setup.py install
~~~

然后修改配置文件，主要修改dev模板段的storage_path到本地的存储仓库的路径

~~~shell
$ cp config/config_sample.yml config/config.yml
~~~

之后启动Web服务

~~~shell
$ sodo gunicorn -c contrib/gunicorn.py docker_registry.wsgi:application
~~~

或者

~~~shell
$ sudo gunicorn --access-logfile - --error-logfile - -k gevent -
b 0.0.0.0:5000 -w 4 --max-requests 100 docker_registry.wsgi:appl
ication
~~~

此时使用curl 访问本地的5000端口，看到输出docker-registry的版本信息说明余小宁成功

***注：config/config_sample.yml 文件时示例配置文件**

#### 在私有仓库上传、下载、搜索镜像

创建号私有仓库后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库，别的机器就可下载。例如私有仓库地址为  192.168.7.26：5000

先在本地产看已有镜像

~~~shell
$ docker images
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED            
 SIZEtset/myip           v1.0.1              320228c9dcec        11 hours ago       
 126MBopenvz/ubuntu       14.04               824857189f82        4 days ago         
 215MBmyip                latest              35fc6503f259        5 days ago         
 159MB
~~~

使用 docker tag 将3202 这个镜像标记为192.168.7.26：5000/test（格式为 docker tag IMAGE[:TAG] [REGISTRYHOST] [USERNAME/]NAME[:TAG]

~~~shell
[root@localhost ~]# docker tag 3202 192.168.7.26:5000
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED            
 SIZE192.168.7.26        5000                320228c9dcec        11 hours ago       
 126MBtset/myip           v1.0.1              320228c9dcec        11 hours ago       
 126MBopenvz/ubuntu       14.04               824857189f82        4 days ago         
 215MB
~~~

使用 docker push 上传标记的镜像

~~~shell
$ sodo push 192.168.7.26:5000/test
The push refers to a repository [192.168.7.26:5000/test] (len: 1
)
Sending image list
Pushing repository 192.168.7.26:5000/test (1 tags)
Image 511136ea3c5a already pushed, skipping
Image 9bad880da3d2 already pushed, skipping
Image 25f11f5fb0cb already pushed, skipping
Image ebc34468f71d already pushed, skipping
Image 2318d26665ef already pushed, skipping
Image ba5877dc9bec already pushed, skipping
Pushing tag for rev [ba5877dc9bec] on {http://192.168.7.26:5000/
v1/repositories/test/tags/latest}
~~~

用 curl 查看仓库中的镜像

~~~shell
curl http://192.168.7.26:5000/v1/search
{"num_results": 7, "query": "", "results": [{"description": "",
"name": "library/miaxis_j2ee"}, {"description": "", "name": "lib
rary/tomcat"}, {"description": "", "name": "library/ubuntu"}, {"
description": "", "name": "library/ubuntu_office"}, {"descriptio
n": "", "name": "library/desktop_ubu"}, {"description": "", "nam
e": "dockerfile/ubuntu"}, {"description": "", "name": "library/t
est"}]}
~~~

可以看到 {“description”：“”，“name”：“library/test”}，表明镜像已上传成功

可以从另一台机器去下载

~~~shell
$ sudo docker pull 192.168.7.26:5000/test
~~~

可以使用[这个脚本](https://github.com/yeasy/docker_practice/raw/master/_local/push_images.sh)批量上传本地的镜像到注册服务器中，默认是本地注册服务器127.0.0.1：5000。

~~~shell
$ wget https://github.com/yeasy/docker_practice/raw/master/_loca
l/push_images.sh; sudo chmod a+x push_images.sh
$ ./push_images.sh ubuntu:latest centos:centos7
The registry server is 127.0.0.1
Uploading ubuntu:latest...
The push refers to a repository [127.0.0.1:5000/ubuntu] (len: 1)
Sending image list
Pushing repository 127.0.0.1:5000/ubuntu (1 tags)
......
Done
~~~

## 仓库配置文件

Docker 的 Registry 利用配置文件提供了一些仓库的模板，可以直接使用它们进行开发和部署

#### 模板

在 config_sample.yml 文件中，可以看到一些现成的模板段：

- common：基础配置
- local：存储数据到本地文件系统
- s3：存储数据到AWS S3中
- dev：使用local 模板的基本配置
- test：单元测试使用
- prod：生产环境配置（基本上跟S3配置类似）
- gcs：存储数据到Google的云存储
- swift：存储数据到OpenStack Swift服务
- glance：存储数据到OpenStack Glance服务，本地文系统为后备
- glance-swift：存储数据到OpenStack Glance 服务，Swift为后备
- elliptics：存储数据到Elliptics key/value存储

用户可以添加自定义模板段。

默认情况下使用的模板是 dev ，要使用某个模板作为默认值，可以添加SETTINGS_FLAVOR 到环境变量中

~~~shell
export SETTINGS_FLAVOR=dev
~~~

#### 示例

~~~~shell
common：
	loglevel: info
	search_backend: "_env:SEARCH_BACKEND:"
	sqlalchemy_index_database:
		"_env:SQLALCHEMY_INDEX_DATABASE:sqlite:////tmp/docker-registry.db"

prod:
	loglevel: warn
	storage: s3
	s3_access_key: _env:AWS_S3_ACCESS_KEY
	s3_secret_key: _env:AWS_S3_SECRET_KEY
	s3_bucket: _env:AWS_S3_BUCKET
	storage_path: /srv/docker
	smtp_host: localhost
	from_addr: docker@myself.com
	to_addr: my@myself.com

dev:
	loglevel: debug
	storage: local
	storage_path: /home/myself/docker

test:
	storage: local
	storage_path: /tmp/tmpdockertmp
~~~~

## Docker 数据管理

Docker 内部以及容器之间管理数据，在容器管理数据主要有两种方式：

- 数据卷（Data volumes）
- 数据卷容器（Data volume containers）

### 数据卷

数据卷是一个可供一个或多个容器使用的特殊目录，他绕过UFS，可以提供很多有用的特性：

- 数据卷可以在容器之间共享和重用
- 对数据卷的修改会立马生效
- 对数据卷的更新，不会影响镜像
- 数据卷默认会一直存在，即使容器被删除

**注：数据卷的使用，类似与Linux下对目录或文件进行mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷**

#### 创建一个数据卷

在使用 docker run 命令的时候，使用 -v 标记来创建一个数据卷并挂载到容器里。在一次run中多次可以使用可以挂载多个数据卷

创建一个名为 web 的容器，并加载一个数据卷到容器的 /webapp 目录

~~~shell
$ sudo docker run -d -P --name web -v /webapp training/webapp py
thon app.py
~~~

**注：也可以在 Dockerfile 中使用 VOLUME 来添加一个或多个新的卷到由该镜像创建的任意容器**

#### 删除数据卷

数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会再容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。无主的数据卷会占据很多空间。

#### 挂载一个主机目录作为数据卷

使用 -v 标记也可以指定挂载一个本地主机的目录到容器中

~~~shell
sudo docker run -d -P --name web -v /src/webapp:/opt/webapp tr
aining/webapp python app.py
~~~

上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp目录。本地目录不惜是绝对路径，如果不存在 Docker 会自动为你创建它

**注：Dockerfile 中不知此此用法，因为 Dockerfile 是为了移植和分享用的，然而不同的操作系统的路径格式不一样，所以目前不支持**

Docker 挂载数据卷的默认权限是读写，用户也可以通过：ro指定为只读。

~~~shell
$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp:ro
training/webapp python app.py
~~~

加了：ro之后，就挂载为只读了

#### 查看数据卷的具体信息

在主机里使用以下命令可以查看指定容器的信息

~~~shell
$ docekr inspect web
...
~~~

在输出的内容中找到其中和数据卷相关的部分，可以看到所有的数据卷都是创建在主机的 /var/lib/docker/volumes/下面的

~~~shell
[root@localhost ~]# docker inspect web
"Volumes": {
"/webapp": "/var/lib/docker/volumes/fac362...80535"
},
"VolumesRW": {
"/webapp": true
}
...
~~~

**注：从 Docker 1.8.0起，数据卷的配置在 "Mounts" Key下，可以看到所有的数据卷都是创建在主机的 /mnt/sda1/var/lib/docker/volumes/...下面**

~~~shell
"Mounts": [
{
"Name": "b53ebd40054dae599faf7c9666acfe205c3e922
fc3e8bc3f2fd178ed788f1c29",
"Source": "/mnt/sda1/var/lib/docker/volumes/b53e
bd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29/_da
ta",
"Destination": "/webapp",
"Driver": "local",
"Mode": "",
"RW": true,
"Propagation": ""
}
]
...
~~~

### 挂载一个本地主机文件作为数据卷

-v 标记可以从主机挂载单个文件到容器中

~~~shell
$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash
~~~

这样就可以记录在容器输入过的命令了。

**注意：如果直接挂载一个文件，很多文件编辑工具，包括 vi 或者 sed --in-
place ，可能会造成文件 inode 的改变，从 Docker 1.1 .0起，这会导致报错误信
息。所以最简单的办法就直接挂载文件的父目录。**

