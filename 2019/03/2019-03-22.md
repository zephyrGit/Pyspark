# 访问容器（二）

### 数据卷容器

如果有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器

数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。首先创建一个名为dbdata的数据卷容器：

~~~shell
$ sudo docker run -d -v /dbdata --name dbdata training/postgres
echo Data-only container for postgres
~~~

然后，在其容器中使用 --volumes-from 来挂载 dbdata 容器中的数据卷

~~~shell
$ sudo docker run -d --volumes-from dbdata --name db1 training/p
ostgres
$ sudo docker run -d --volumes-from dbdata --name db2 training/p
ostgres
~~~

可以使用超过一个的 --volumes-from 参数来指定从多个容器挂载不同的数据卷。也可以从其他已经挂载了数据卷的容器来级联挂载数据卷

~~~shell
$ sudo docker run -d --name db3 --volumes-from db1 training/post
gres
~~~

**注：使用 --volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态**

如果删除了挂载的容器 （包括dbdata、db1和db2），数据卷并不会被自动删除。如果要删除一个数据卷，**必须在删除最后一个还挂载着它的容器时使用 docker rm -v 命令来指定董事删除关联的容器。**可以让用户在容器之间升级和移动数据卷。

### 利用数据卷容器来备份、恢复、迁移数据卷

#### 备份

首先使用 --volumes-from 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup/ 目录。 命令如下：

~~~shell
$ sudo docker run --volumes-from dbdata -v $(pwd):/backup ubuntu
tar cvf /backup/backup.tar /dbdata
~~~

容器启动后，使用了 tar 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下名为 backup.tar 文件

#### 恢复

如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2.

~~~shell
$ sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash
~~~

然后创建另一个容器，挂载一个 dbdata2 容器卷中的数据卷，并使用 untar 解压备份文件放到挂载的容器卷中

~~~shell
$ sudo docker run --volumes-from dbdata2 -v $(pwd):/backup busyb
ox tar xvf
/backup/backup.tar
~~~

为了查看/检验恢复的数据，可以再启动一个容器挂载同样的容器卷来查看

~~~shell
$ sudo docker run --volumes-from dbdata2 busybox /bin/ls /dbdata
~~~

### Docker 中的网络功能

Docker 允许通过外部访问容器或容器互联的方式来提供网络服务

#### 外部访问容器

容器中可以运行一些网络应用，要让外部也可以访问呢这些应用，可以通过 -P 或 -p 参数来指定端口映射。

当使用 -P 标记时，Docker 会随机映射一个 49000~49900的端口到内部容器开放的网络端口。

使用 docker ps 可以看到，本地主机的49155被映射到了容器的5000端口。此时访问本机的49155端口即可访问容器内web应用提供的界面

~~~shell
$ sudo docker run -d -P training/webapp python app.py
$ sudo docker ps -l
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NAMES
bc533791f3f5 training/webapp:latest python app.py 5 seconds ag
o Up 2 seconds 0.0.0.0:49155->5000/tcp nostalgic_morse
~~~

同样，可以通过 docker logs 命令来查看应用的信息

~~~shell
$ sudo docker logs -f nostalgic_morse
* Running on http://0.0.0.0:5000/
10.0.2.2 - - [23/May/2014 20:16:31] "GET / HTTP/1.1" 200 -
10.0.2.2 - - [23/May/2014 20:16:31] "GET /favicon.ico HTTP/1.1"
404 -
~~~

-p(小写)则可以指定要映射的端口，并且在一个指定端口上只可以绑定一个容器。支持的格式有 ip:hostPort:containerPort | ip:containerPort | hostPort:containerPort

#### 映射所有接口地址

使用 hostPorrt：containerPort 格式本地的 5000 端口映射到容器的 5000 端口，可以执行

~~~shell
$ sudo docker run -d -p 5000:5000 training/webapp python app.py
~~~

此时默认会绑定本地所有接口上的所有地址

#### 映射到指定的指定端口

可以使用 ip：hostPort：containerPort 格式指定映射使用一个特定地址，比如hocalhost 地址 127.0.0.1

~~~shell
$ sudo docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py
~~~

#### 映射到指定地址的任意端口

使用 ip::containerPort 绑定 localhost 的任意端口 到容器的 5000 端口，本地主机会自动分配一个端口

~~~shell
$ sudo docker run -d -p 127.0.0.1::5000 training/webapp python app.py
~~~

也可以使用 udp 标记来指定 udp 端口

~~~shell
$ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
~~~

#### 查看映射端口配置

使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址

~~~shell
$ docker port nostalgic_morse 5000
127.0.0.1:49155.
~~~

**注意**

- 容器有自己内部网络和ip地址（使用 docker inspect 可以获取所有的变量， Docker 还可以有一个可变的网络配置）
- -p 标记可以多次使用来绑定多个端口

~~~shell
# 例如
$ sudo docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py
~~~

#### 容器互联

容器的链接系统时除了端口映射外，另一种跟容器中应用交互的方式。该系统会在源和接收容器之间创建一个隧道，接收容器可以看到容器指定的信息

#### 自定义容器命名

连接系统依据容器的名称来执行。因此，首先要自定义一个好记的命令。

虽然当创建容器的时候，系统默认会分配一个名字。自定一命名有两个好处：

- 自定义的命名：比较好记
- 当需要连接其他容器的时候，可以作为一个有用的参考点，比如连接wbe容器到db容器

使用 -- name标记以为容器自定义命名

~~~shell
$ sudo docker run -d -P --name web training/webapp python app.py
~~~

使用 docker ps 来验证设定的命名

~~~shell
$ sudo docker ps -l
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NAMES
aed84ee21bde training/webapp:latest python app.py 12 hours ago Up 2 seconds 0.0.0.0:49154->5000/tcp web
~~~

也可以使用 docker inspect 来查看容器的名字

~~~shell
$ sudo docker inspect -f "{{ .Name }}" aed84ee21bde
/web
~~~

**注意：容器的名称时唯一的。如果已经有一个名叫 web 的容器，当你要再次使用 web 这个名称的时候，需要先用 docker rm 来删除之前的同名容器**

在执行 docker run 的时候如果添加 --rm 标记，则容器在终止后会立即删除。 注意： --rm 和 -d 参数不能同时使用

#### 容器互联

使用 --link 参数可以让容器之间安全的进行交互

创建一个新的数据库容器

~~~shell
$ sudo docker run -d --name db training/postgres
~~~

删除已创建的 web 容器

~~~shell
$ docker rm -f web
~~~

然后创建一个新的 web 容器，并将它连接到 db 容器

~~~shell
$ sudo docker run -d -P --name web --link db:db training/webapp python app.py
~~~

此时，db容器和web 容器建立互联关系

--link 参数的格式为 --link name:alias ，其中 name 是要连接的容器的名称，alias 是个连接的别名

使用 docker ps 来查看容器的连接

~~~shell
$ docker ps 
CONTAINER ID IMAGE COMMAND CR
EATED STATUS PORTS NA
MES
349169744e49 training/postgres:latest su postgres -c '/usr Ab
out a minute ago Up About a minute 5432/tcp db, web/db
aed84ee21bde training/webapp:latest python app.py 16
hours ago Up 2 minutes 0.0.0.0:49154->5000/tcp web
~~~

可以看到自定义命名的容器， db和 web， db容器的names列有 db 也有web/db。表示web容器连接到db容器，web容器将被允许访问 db 容器的信息。

Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射他们的端口到宿主主机上。在启动 db 容器的时候并没有使用 -p 和 -P 标记，从而避免了暴露数据库端口到外部网络上

Docker 通过 2 种方式为容器公开连接信息：

- 环境变量
- 更新 /etc/hosts 文件

使用 env 命令来查看 web 容器的环境变量

~~~shell
$ sudo docker run --rm --name web2 --link db:db training/webapp
env
. . .
DB_NAME=/web2/db
DB_PORT=tcp://172.17.0.5:5432
DB_PORT_5000_TCP=tcp://172.17.0.5:5432
DB_PORT_5000_TCP_PROTO=tcp
DB_PORT_5000_TCP_PORT=5432
DB_PORT_5000_TCP_ADDR=172.17.0.5
. . .
~~~

其中 DB_ 开头的环境变量是供 web 容器连接到 db 容器使用，前缀采用大写的连接别名

除了环境变量， Docker还添加host信息到父容器的 /etc/hosts 的文件，下面是父容器 web 的 hosts 文件

~~~shell
$ sudo docker run -t -i --rm --link db:db training/webapp /bin/bash
root@aed84ee21bde:/opt/webapp# cat /etc/hosts
172.17.0.7 aed84ee21bde
. . .
172.17.0.5 db
~~~

这里有2个hosts，第一个是web 容器，web容器用id作为他的主机，第二个是 db 容器的ip和主机名。可以在 web 容器中安装ping命令来测试跟db容器的相连通

~~~shell
root@aed84ee21bde:/opt/webapp# apt-get install -yqq inetutils-ping
root@aed84ee21bde:/opt/webapp# ping db
PING db (172.17.0.5): 48 data bytes
56 bytes from 172.17.0.5: icmp_seq=0 ttl=64 time=0.267 ms
56 bytes from 172.17.0.5: icmp_seq=1 ttl=64 time=0.250 ms
56 bytes from 172.17.0.5: icmp_seq=2 ttl=64 time=0.256 ms
~~~

用 ping 来测试db容器，它会解析成 172.17.0.5 。 *注意：官方的 ubuntu 镜像
默认没有安装 ping，需要自行安装。
用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。

